import { 
  VulnerabilityIndex, 
  VIComponents, 
  NLPAnalysis, 
  ScrollMetrics, 
  AnalysisWindow,
  Platform 
} from '../types/index.js';

export class VulnerabilityIndexCalculator {
  private history: VulnerabilityIndex[] = [];
  private analysisWindows: AnalysisWindow[] = [];
  private readonly HISTORY_LIMIT = 1000;
  private readonly WINDOW_SIZE_MS = 30000; // 30 seconds
  private readonly DECAY_HALF_LIFE_MS = 600000; // 10 minutes

  // Configuration weights
  private readonly weights = {
    sentiment: 0.25,
    distortion: 0.35,
    rage: 0.20,
    timeIntensity: 0.10,
    crossPlatform: 0.05,
    scroll: 0.05
  };

  constructor() {
    this.startDecayTimer();
  }

  /**
   * Calculate vulnerability index from current analysis
   */
  public calculateVI(
    nlpAnalysis: NLPAnalysis,
    scrollMetrics: ScrollMetrics[],
    timeIntensity: number,
    crossPlatformFactor: number = 0,
    platform: Platform
  ): VulnerabilityIndex {
    const timestamp = Date.now();
    
    // Calculate individual components
    const components = this.calculateComponents(
      nlpAnalysis,
      scrollMetrics,
      timeIntensity,
      crossPlatformFactor
    );

    // Calculate overall VI score
    const current = this.calculateOverallScore(components);
    
    // Calculate trend
    const trend = this.calculateTrend(current);
    
    // Calculate confidence
    const confidence = this.calculateConfidence(nlpAnalysis, scrollMetrics);

    const vi: VulnerabilityIndex = {
      current,
      trend,
      components,
      timestamp,
      confidence
    };

    // Add to history
    this.addToHistory(vi);

    return vi;
  }

  /**
   * Calculate VI components
   */
  private calculateComponents(
    nlpAnalysis: NLPAnalysis,
    scrollMetrics: ScrollMetrics[],
    timeIntensity: number,
    crossPlatformFactor: number
  ): VIComponents {
    return {
      sentiment: this.calculateSentimentScore(nlpAnalysis.sentiment),
      distortion: this.calculateDistortionScore(nlpAnalysis.cognitiveDistortions),
      rage: this.calculateRageScore(nlpAnalysis.rageIndicators),
      timeIntensity: Math.min(1, timeIntensity),
      crossPlatform: Math.min(1, crossPlatformFactor),
      scroll: this.calculateScrollScore(scrollMetrics)
    };
  }

  /**
   * Calculate overall VI score from components
   */
  private calculateOverallScore(components: VIComponents): number {
    const score = (
      components.sentiment * this.weights.sentiment +
      components.distortion * this.weights.distortion +
      components.rage * this.weights.rage +
      components.timeIntensity * this.weights.timeIntensity +
      components.crossPlatform * this.weights.crossPlatform +
      components.scroll * this.weights.scroll
    );

    return Math.min(100, Math.max(0, score * 100));
  }

  /**
   * Calculate sentiment component score
   */
  private calculateSentimentScore(sentiment: any): number {
    if (!sentiment) return 0;

    // Negative valence with high arousal increases vulnerability
    const negativeValence = Math.max(0, -sentiment.valence);
    const arousalFactor = sentiment.arousal;
    const confidenceFactor = sentiment.confidence;

    return (negativeValence * 0.6 + arousalFactor * 0.4) * confidenceFactor;
  }

  /**
   * Calculate distortion component score
   */
  private calculateDistortionScore(distortions: any[]): number {
    if (!distortions || distortions.length === 0) return 0;

    // Weight different distortion types
    const typeWeights = {
      persecution: 0.9,
      conspiracy: 0.8,
      grandiosity: 0.6,
      catastrophizing: 0.7,
      all_or_nothing: 0.5,
      mind_reading: 0.6,
      fortune_telling: 0.5
    };

    let totalScore = 0;
    for (const distortion of distortions) {
      const weight = typeWeights[distortion.type as keyof typeof typeWeights] || 0.5;
      totalScore += distortion.severity * weight;
    }

    return Math.min(1, totalScore);
  }

  /**
   * Calculate rage component score
   */
  private calculateRageScore(rageIndicators: any[]): number {
    if (!rageIndicators || rageIndicators.length === 0) return 0;

    const typeWeights = {
      verbal_aggression: 0.7,
      threat_language: 1.0,
      profanity: 0.4,
      caps_lock: 0.3,
      exclamation_spam: 0.2
    };

    let totalScore = 0;
    for (const indicator of rageIndicators) {
      const weight = typeWeights[indicator.type as keyof typeof typeWeights] || 0.5;
      totalScore += indicator.intensity * weight;
    }

    return Math.min(1, totalScore);
  }

  /**
   * Calculate scroll component score
   */
  private calculateScrollScore(scrollMetrics: ScrollMetrics[]): number {
    if (!scrollMetrics || scrollMetrics.length === 0) return 0;

    const recentMetrics = scrollMetrics.filter(m => 
      Date.now() - m.timestamp < 30000 // Last 30 seconds
    );

    if (recentMetrics.length === 0) return 0;

    // Calculate rage scrolling indicators
    const rapidScrolls = recentMetrics.filter(m => m.velocity > 1000);
    const rapidScrollRatio = rapidScrolls.length / recentMetrics.length;
    
    // Calculate direction changes
    let directionChanges = 0;
    for (let i = 1; i < recentMetrics.length; i++) {
      if (recentMetrics[i].direction !== recentMetrics[i-1].direction) {
        directionChanges++;
      }
    }
    const directionChangeRatio = directionChanges / Math.max(recentMetrics.length - 1, 1);

    // Calculate average dwell time
    const avgDwellTime = recentMetrics.reduce((sum, m) => sum + m.dwellTime, 0) / recentMetrics.length;
    const lowDwellScore = Math.max(0, 1 - avgDwellTime / 2000);

    return (rapidScrollRatio * 0.4 + directionChangeRatio * 0.3 + lowDwellScore * 0.3);
  }

  /**
   * Calculate trend based on recent history
   */
  private calculateTrend(currentScore: number): number {
    if (this.history.length < 2) return 0;

    const recent = this.history.slice(-10); // Last 10 readings
    const earlier = this.history.slice(-20, -10); // Previous 10 readings

    if (earlier.length === 0) return 0;

    const recentAvg = recent.reduce((sum, vi) => sum + vi.current, 0) / recent.length;
    const earlierAvg = earlier.reduce((sum, vi) => sum + vi.current, 0) / earlier.length;

    const trend = (recentAvg - earlierAvg) / 100; // Normalize to -1 to 1
    return Math.max(-1, Math.min(1, trend));
  }

  /**
   * Calculate confidence in the VI score
   */
  private calculateConfidence(nlpAnalysis: NLPAnalysis, scrollMetrics: ScrollMetrics[]): number {
    let confidence = 0;
    let factors = 0;

    // NLP analysis confidence
    if (nlpAnalysis.confidence > 0) {
      confidence += nlpAnalysis.confidence;
      factors++;
    }

    // Scroll data confidence (based on amount of data)
    if (scrollMetrics.length > 0) {
      const scrollConfidence = Math.min(1, scrollMetrics.length / 10);
      confidence += scrollConfidence;
      factors++;
    }

    // Time-based confidence (more data over time = higher confidence)
    if (this.history.length > 0) {
      const historyConfidence = Math.min(1, this.history.length / 20);
      confidence += historyConfidence;
      factors++;
    }

    return factors > 0 ? confidence / factors : 0;
  }

  /**
   * Add VI to history
   */
  private addToHistory(vi: VulnerabilityIndex): void {
    this.history.push(vi);
    
    // Limit history size
    if (this.history.length > this.HISTORY_LIMIT) {
      this.history.shift();
    }
  }

  /**
   * Get recent VI history
   */
  public getRecentHistory(durationMs: number = 3600000): VulnerabilityIndex[] {
    const cutoff = Date.now() - durationMs;
    return this.history.filter(vi => vi.timestamp > cutoff);
  }

  /**
   * Get VI statistics
   */
  public getStatistics(durationMs: number = 3600000): {
    current: number;
    average: number;
    peak: number;
    trend: number;
    timeAboveThreshold: number;
    riskLevel: 'low' | 'medium' | 'high';
  } {
    const recent = this.getRecentHistory(durationMs);
    
    if (recent.length === 0) {
      return {
        current: 0,
        average: 0,
        peak: 0,
        trend: 0,
        timeAboveThreshold: 0,
        riskLevel: 'low'
      };
    }

    const current = recent[recent.length - 1].current;
    const average = recent.reduce((sum, vi) => sum + vi.current, 0) / recent.length;
    const peak = Math.max(...recent.map(vi => vi.current));
    const trend = recent[recent.length - 1].trend;
    
    // Calculate time above threshold (70)
    const aboveThreshold = recent.filter(vi => vi.current > 70);
    const timeAboveThreshold = aboveThreshold.length > 0 ? 
      (aboveThreshold[aboveThreshold.length - 1].timestamp - aboveThreshold[0].timestamp) / 1000 : 0;

    // Determine risk level
    let riskLevel: 'low' | 'medium' | 'high' = 'low';
    if (current > 85 || (current > 70 && trend > 0.3)) {
      riskLevel = 'high';
    } else if (current > 60 || (current > 50 && trend > 0.2)) {
      riskLevel = 'medium';
    }

    return {
      current,
      average,
      peak,
      trend,
      timeAboveThreshold,
      riskLevel
    };
  }

  /**
   * Check if intervention should be triggered
   */
  public shouldTriggerIntervention(thresholds: {
    viThreshold?: number;
    durationMs?: number;
    trendThreshold?: number;
  } = {}): boolean {
    const {
      viThreshold = 70,
      durationMs = 180000, // 3 minutes
      trendThreshold = 0.3
    } = thresholds;

    if (this.history.length === 0) return false;

    const current = this.history[this.history.length - 1];
    
    // Check current VI threshold
    if (current.current > viThreshold) {
      // Check if sustained above threshold
      const since = Date.now() - durationMs;
      const sustainedHigh = this.history.filter(vi => 
        vi.timestamp > since && vi.current > viThreshold
      );
      
      if (sustainedHigh.length > 0) {
        const sustainedDuration = Date.now() - sustainedHigh[0].timestamp;
        if (sustainedDuration > durationMs) {
          return true;
        }
      }
    }

    // Check for rapid increase
    if (current.trend > trendThreshold && current.current > viThreshold * 0.8) {
      return true;
    }

    return false;
  }

  /**
   * Apply decay to VI based on inactivity
   */
  private applyDecay(): void {
    if (this.history.length === 0) return;

    const lastVI = this.history[this.history.length - 1];
    const timeSinceLastUpdate = Date.now() - lastVI.timestamp;

    // Apply exponential decay
    if (timeSinceLastUpdate > 60000) { // 1 minute of inactivity
      const decayFactor = Math.exp(-timeSinceLastUpdate / this.DECAY_HALF_LIFE_MS);
      const decayedScore = lastVI.current * decayFactor;
      
      if (decayedScore < lastVI.current - 5) { // Only update if significant change
        const decayedVI: VulnerabilityIndex = {
          ...lastVI,
          current: decayedScore,
          trend: -0.1, // Negative trend due to decay
          timestamp: Date.now()
        };
        
        this.addToHistory(decayedVI);
      }
    }
  }

  /**
   * Start decay timer
   */
  private startDecayTimer(): void {
    setInterval(() => {
      this.applyDecay();
    }, 60000); // Check every minute
  }

  /**
   * Get current VI level
   */
  public getCurrentLevel(): VulnerabilityIndex | null {
    return this.history.length > 0 ? this.history[this.history.length - 1] : null;
  }

  /**
   * Clear history
   */
  public clearHistory(): void {
    this.history = [];
  }
} 